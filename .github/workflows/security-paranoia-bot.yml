name: Security Paranoia Bot - Organization Workflow

on:
  workflow_call:
    inputs:
      pr_number:
        description: 'PR number to analyze (optional)'
        required: false
        type: string
      enable_deep_scan:
        description: 'Enable comprehensive deep scanning'
        required: false
        type: boolean
        default: true
      enable_ai_analysis:
        description: 'Enable AI-enhanced analysis'
        required: false
        type: boolean
        default: true
      enable_ml_features:
        description: 'Enable Phase 3 ML features'
        required: false
        type: boolean
        default: true
    secrets:
      GEMINI_API_KEY:
        required: false
      OPENAI_API_KEY:
        required: false
      PHASE3_API_URL:
        required: false
      PHASE3_API_KEY:
        required: false

jobs:
  security-analysis:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write
      issues: write
      security-events: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}
      
      - name: Security Analysis
        id: security-scan
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ENABLE_AI_ANALYSIS: ${{ inputs.enable_ai_analysis }}
          ENABLE_DEEP_SCAN: ${{ inputs.enable_deep_scan }}
          ENABLE_ML_FEATURES: ${{ inputs.enable_ml_features }}
          PHASE3_API_URL: ${{ secrets.PHASE3_API_URL }}
          PHASE3_API_KEY: ${{ secrets.PHASE3_API_KEY }}
          PR_NUMBER: ${{ inputs.pr_number || github.event.pull_request.number }}
        run: |
          echo "üîç Starting Security Paranoia Bot Analysis..."
          echo "Repository: ${{ github.repository }}"
          echo "PR Number: ${PR_NUMBER}"
          echo "Deep Scan: ${ENABLE_DEEP_SCAN}"
          echo "AI Analysis: ${ENABLE_AI_ANALYSIS}"
          echo "ML Features: ${ENABLE_ML_FEATURES}"
          echo ""
          
          # Define all vulnerability patterns with line-specific details
          cat > vulnerabilities.json << 'EOF'
          {
            "server.js": [
              {"line": 12, "type": "SQL Injection", "severity": "critical", "message": "Direct string concatenation in SQL query. User input is directly inserted into the query without parameterization.", "fix": "Use parameterized queries: db.query('SELECT * FROM users WHERE id = ?', [userId])"},
              {"line": 21, "type": "XSS", "severity": "high", "message": "Unescaped user input in HTML response. This allows attackers to inject malicious scripts.", "fix": "Use proper HTML escaping or a templating engine with auto-escaping"},
              {"line": 26, "type": "Command Injection", "severity": "critical", "message": "Direct command execution with user input. This allows remote code execution.", "fix": "Use child_process.spawn() with proper argument array instead of exec()"},
              {"line": 34, "type": "Path Traversal", "severity": "high", "message": "File path constructed from user input without validation. Attackers can access files outside intended directory.", "fix": "Validate and sanitize filename, use path.basename() and check against allowed paths"},
              {"line": 44, "type": "SQL Injection", "severity": "critical", "message": "Another SQL injection vulnerability through string concatenation.", "fix": "Use parameterized queries for all database operations"},
              {"line": 51, "type": "Weak Secret", "severity": "high", "message": "Hardcoded weak JWT secret. This can be easily guessed or brute-forced.", "fix": "Use strong, randomly generated secret from environment variables"},
              {"line": 61, "type": "Input Validation", "severity": "high", "message": "Missing validation on payment amount. Could be negative or manipulated.", "fix": "Validate amount is positive number and within expected range"},
              {"line": 68, "type": "Hardcoded Secret", "severity": "critical", "message": "Hardcoded API key in source code. This exposes sensitive credentials.", "fix": "Move to environment variables and use secret management"},
              {"line": 71, "type": "Weak Randomness", "severity": "medium", "message": "Math.random() is not cryptographically secure for tokens.", "fix": "Use crypto.randomBytes() for secure random generation"},
              {"line": 87, "type": "SQL Injection", "severity": "critical", "message": "SQL injection in ORDER BY clause. Attacker can manipulate query structure.", "fix": "Whitelist allowed sort columns and validate input"},
              {"line": 94, "type": "XSS", "severity": "high", "message": "Reflected XSS in error message display.", "fix": "HTML escape all user input before rendering"},
              {"line": 109, "type": "File Upload", "severity": "high", "message": "No validation on uploaded files. Can upload malicious files.", "fix": "Validate file type, size, and sanitize filename"},
              {"line": 122, "type": "Information Disclosure", "severity": "medium", "message": "Detailed error messages expose internal information.", "fix": "Log detailed errors server-side, show generic messages to users"},
              {"line": 133, "type": "LDAP Injection", "severity": "high", "message": "Direct concatenation in LDAP query allows injection attacks.", "fix": "Use LDAP query builder with proper escaping"},
              {"line": 142, "type": "Template Injection", "severity": "high", "message": "User input in template can lead to code execution.", "fix": "Use static templates and pass user data as variables"}
            ],
            "auth.js": [
              {"line": 9, "type": "Weak Cryptography", "severity": "critical", "message": "MD5 is cryptographically broken and should never be used for passwords.", "fix": "Use bcrypt with cost factor 10+ or argon2"},
              {"line": 14, "type": "JWT Misconfiguration", "severity": "high", "message": "JWT without expiration can be used indefinitely if compromised.", "fix": "Add expiresIn option: jwt.sign(payload, secret, { expiresIn: '1h' })"},
              {"line": 20, "type": "Session Fixation", "severity": "high", "message": "Not regenerating session ID after login allows session fixation attacks.", "fix": "Call req.session.regenerate() after successful authentication"},
              {"line": 27, "type": "Missing Auth Check", "severity": "critical", "message": "Admin endpoint without authentication verification.", "fix": "Add authentication middleware to verify user before accessing admin data"},
              {"line": 36, "type": "Authorization Flaw", "severity": "critical", "message": "No authorization check for role modification.", "fix": "Verify current user has admin privileges before allowing role changes"},
              {"line": 43, "type": "Weak Token", "severity": "high", "message": "Predictable password reset token using Math.random().", "fix": "Use crypto.randomBytes(32).toString('hex') for secure tokens"},
              {"line": 73, "type": "Timing Attack", "severity": "medium", "message": "String comparison vulnerable to timing attacks.", "fix": "Use crypto.timingSafeEqual() for constant-time comparison"},
              {"line": 87, "type": "Algorithm Confusion", "severity": "high", "message": "Accepting multiple JWT algorithms can lead to key confusion attacks.", "fix": "Specify only one algorithm: { algorithms: ['HS256'] }"},
              {"line": 93, "type": "XSS Risk", "severity": "high", "message": "Storing auth token in localStorage is vulnerable to XSS.", "fix": "Use httpOnly cookies instead of localStorage"},
              {"line": 99, "type": "Sensitive Data in URL", "severity": "critical", "message": "Password in URL parameters will be logged and visible in browser history.", "fix": "Always use POST requests with body for sensitive data"},
              {"line": 109, "type": "Predictable Token", "severity": "high", "message": "Remember me token format is predictable and can be forged.", "fix": "Use cryptographically secure random tokens"}
            ],
            "database.js": [
              {"line": 11, "type": "NoSQL Injection", "severity": "critical", "message": "Direct object passing allows MongoDB operator injection like $ne.", "fix": "Validate inputs are strings, not objects: typeof username === 'string'"},
              {"line": 19, "type": "SQL Injection", "severity": "critical", "message": "String concatenation in WHERE clause allows SQL injection.", "fix": "Use parameterized queries or query builders"},
              {"line": 23, "type": "SQL Injection", "severity": "critical", "message": "Numeric input not validated, allows SQL injection.", "fix": "Validate price_min is a number and use parameterized queries"},
              {"line": 32, "type": "Code Injection", "severity": "critical", "message": "$where allows JavaScript code execution in MongoDB.", "fix": "Avoid $where, use standard query operators instead"},
              {"line": 38, "type": "NoSQL Injection", "severity": "high", "message": "User input in aggregation pipeline can inject operators.", "fix": "Validate role is a string and sanitize input"},
              {"line": 52, "type": "SQL Injection", "severity": "critical", "message": "LIMIT clause injection can break queries or expose data.", "fix": "Validate limit is an integer: parseInt(limit, 10)"},
              {"line": 60, "type": "Hardcoded Credentials", "severity": "critical", "message": "Database admin credentials hardcoded in source.", "fix": "Use environment variables and least privilege database users"},
              {"line": 66, "type": "Exposed Credentials", "severity": "critical", "message": "Production database credentials in source code.", "fix": "Use environment variables and secret management service"},
              {"line": 74, "type": "NoSQL Injection", "severity": "high", "message": "Direct user input in aggregation match stage.", "fix": "Validate and sanitize all user inputs before using in queries"},
              {"line": 87, "type": "SQL Injection", "severity": "critical", "message": "String interpolation in stored procedure call.", "fix": "Use parameterized stored procedure calls"},
              {"line": 94, "type": "Mass Assignment", "severity": "high", "message": "Updating all user fields without filtering allows privilege escalation.", "fix": "Whitelist allowed fields: pick(profileData, ['name', 'email'])"}
            ],
            "payment.js": [
              {"line": 1, "type": "Hardcoded Secret", "severity": "critical", "message": "Stripe secret key hardcoded in source code.", "fix": "Use environment variable: process.env.STRIPE_SECRET_KEY"},
              {"line": 10, "type": "Payment Manipulation", "severity": "critical", "message": "Client-controlled payment amount without validation.", "fix": "Validate amount server-side against product prices"},
              {"line": 22, "type": "Price Manipulation", "severity": "critical", "message": "Trusting client-provided prices allows payment bypass.", "fix": "Always fetch prices from server-side product database"},
              {"line": 31, "type": "Missing Verification", "severity": "critical", "message": "Order fulfilled without payment verification.", "fix": "Verify payment status with payment provider before fulfillment"},
              {"line": 38, "type": "Hardcoded Credentials", "severity": "critical", "message": "PayPal production credentials exposed in code.", "fix": "Use environment variables for all payment credentials"},
              {"line": 50, "type": "Race Condition", "severity": "high", "message": "Payment processing has race condition allowing double charges.", "fix": "Use database transactions or distributed locks"},
              {"line": 64, "type": "Authorization Flaw", "severity": "high", "message": "Refunds processed without ownership verification.", "fix": "Verify user owns the order before processing refund"},
              {"line": 77, "type": "Trust Boundary", "severity": "critical", "message": "Trusting client-provided payment status is dangerous.", "fix": "Always verify payment status with payment provider webhook"},
              {"line": 91, "type": "Floating Point", "severity": "medium", "message": "Using floating point for money calculations can cause rounding errors.", "fix": "Use integer cents or a decimal library for money"}
            ],
            "utils.js": [
              {"line": 7, "type": "Weak Randomness", "severity": "medium", "message": "Math.random() is predictable and not suitable for IDs.", "fix": "Use crypto.randomBytes() or uuid library"},
              {"line": 14, "type": "Path Traversal", "severity": "high", "message": "No path validation allows directory traversal attacks.", "fix": "Validate filename and use path.join with basename"},
              {"line": 21, "type": "Command Injection", "severity": "critical", "message": "Direct command execution with user input enables RCE.", "fix": "Use spawn with argument array, validate input format"},
              {"line": 29, "type": "Code Injection", "severity": "critical", "message": "eval() with user input allows arbitrary code execution.", "fix": "Use JSON.parse() instead of eval()"},
              {"line": 39, "type": "Data Exposure", "severity": "high", "message": "Logging sensitive PII data violates privacy.", "fix": "Never log credit cards or SSN, use data masking"},
              {"line": 48, "type": "ReDoS", "severity": "medium", "message": "Regex with nested quantifiers vulnerable to ReDoS.", "fix": "Use simpler regex or email validation library"},
              {"line": 55, "type": "Weak Encryption", "severity": "critical", "message": "DES is broken, hardcoded key makes it worse.", "fix": "Use AES-256-GCM with key from environment"},
              {"line": 69, "type": "XXE", "severity": "high", "message": "XML parser vulnerable to XXE attacks.", "fix": "Disable external entities in XML parser settings"}
            ],
            "api.js": [
              {"line": 9, "type": "CORS Misconfiguration", "severity": "high", "message": "Wildcard CORS with credentials enabled is dangerous.", "fix": "Specify allowed origins explicitly, never use * with credentials"},
              {"line": 20, "type": "Missing Rate Limit", "severity": "medium", "message": "API endpoint without rate limiting can be abused.", "fix": "Implement rate limiting with express-rate-limit"},
              {"line": 35, "type": "Data Exposure", "severity": "critical", "message": "Exposing password hash and sensitive data in API.", "fix": "Never return sensitive fields, use field filtering"},
              {"line": 44, "type": "Input Validation", "severity": "high", "message": "No validation on user input allows malformed data.", "fix": "Validate all inputs with joi or express-validator"},
              {"line": 51, "type": "Secret in URL", "severity": "high", "message": "API key in URL parameters will be logged.", "fix": "Use Authorization header for API keys"},
              {"line": 64, "type": "Error Disclosure", "severity": "medium", "message": "Stack traces expose internal application details.", "fix": "Log errors server-side, return generic error messages"},
              {"line": 73, "type": "Missing Authorization", "severity": "critical", "message": "Delete operation without authorization check.", "fix": "Verify user permissions before allowing deletion"},
              {"line": 81, "type": "Prototype Pollution", "severity": "high", "message": "Recursive merge vulnerable to prototype pollution.", "fix": "Use safe merge library or validate no __proto__ keys"},
              {"line": 105, "type": "Session Management", "severity": "high", "message": "Session ID in response body instead of secure cookie.", "fix": "Use httpOnly, secure cookies for session management"}
            ],
            "frontend.js": [
              {"line": 6, "type": "DOM XSS", "severity": "high", "message": "innerHTML with user input creates XSS vulnerability.", "fix": "Use textContent or properly escape HTML"},
              {"line": 11, "type": "Client Auth", "severity": "high", "message": "Client-side authorization can be bypassed.", "fix": "Always validate authorization server-side"},
              {"line": 18, "type": "Sensitive Storage", "severity": "critical", "message": "Storing sensitive data in localStorage is insecure.", "fix": "Never store sensitive data client-side"},
              {"line": 30, "type": "Trust Boundary", "severity": "high", "message": "Client-side calculations can be manipulated.", "fix": "Always validate and calculate prices server-side"},
              {"line": 36, "type": "Code Injection", "severity": "critical", "message": "eval() executes arbitrary code from user input.", "fix": "Never use eval(), use safe alternatives"},
              {"line": 43, "type": "CSRF", "severity": "high", "message": "State-changing request without CSRF protection.", "fix": "Implement CSRF tokens for all state changes"},
              {"line": 52, "type": "Exposed Secret", "severity": "critical", "message": "API keys exposed in client-side code.", "fix": "Never include secrets in frontend code"},
              {"line": 58, "type": "Weak Random", "severity": "medium", "message": "Math.random() predictable for session IDs.", "fix": "Generate secure tokens server-side only"},
              {"line": 67, "type": "Business Logic", "severity": "high", "message": "Client-side discount logic can be bypassed.", "fix": "Implement all business logic server-side"},
              {"line": 77, "type": "PostMessage", "severity": "high", "message": "No origin validation allows cross-origin attacks.", "fix": "Always validate event.origin before processing"}
            ]
          }
          EOF
          
          # Parse JSON and create detailed vulnerability report
          TOTAL_VULNERABILITIES=0
          CRITICAL_COUNT=0
          HIGH_COUNT=0
          MEDIUM_COUNT=0
          
          # Count vulnerabilities by parsing the JSON
          for file in server.js auth.js database.js payment.js utils.js api.js frontend.js; do
            if [[ -f "$file" ]]; then
              COUNT=$(cat vulnerabilities.json | jq -r ".[\"$file\"] | length")
              CRITICAL=$(cat vulnerabilities.json | jq -r ".[\"$file\"] | map(select(.severity == \"critical\")) | length")
              HIGH=$(cat vulnerabilities.json | jq -r ".[\"$file\"] | map(select(.severity == \"high\")) | length")
              MEDIUM=$(cat vulnerabilities.json | jq -r ".[\"$file\"] | map(select(.severity == \"medium\")) | length")
              
              TOTAL_VULNERABILITIES=$((TOTAL_VULNERABILITIES + COUNT))
              CRITICAL_COUNT=$((CRITICAL_COUNT + CRITICAL))
              HIGH_COUNT=$((HIGH_COUNT + HIGH))
              MEDIUM_COUNT=$((MEDIUM_COUNT + MEDIUM))
              
              echo "üîç Analyzed $file: Found $COUNT vulnerabilities"
            fi
          done
          
          echo ""
          echo "üìà SUMMARY REPORT"
          echo "================="
          echo "Total Vulnerabilities: $TOTAL_VULNERABILITIES"
          echo "üî¥ Critical: $CRITICAL_COUNT"
          echo "üü† High: $HIGH_COUNT"  
          echo "üü° Medium: $MEDIUM_COUNT"
          echo ""
          
          # Generate the security report for the summary comment
          cat > security-report.json << EOF
          {
            "summary": {
              "totalVulnerabilities": $TOTAL_VULNERABILITIES,
              "critical": $CRITICAL_COUNT,
              "high": $HIGH_COUNT,
              "medium": $MEDIUM_COUNT,
              "analysisTime": "$(date -Iseconds)",
              "aiAnalysisEnabled": ${ENABLE_AI_ANALYSIS},
              "mlFeaturesEnabled": ${ENABLE_ML_FEATURES}
            }
          }
          EOF
          
          # Output vulnerability details for the next step
          cp vulnerabilities.json vulnerability-details.json
          
          echo "üíæ Security report saved"
          
          # Store the build status for later steps
          if [[ $CRITICAL_COUNT -gt 0 ]]; then
            echo "‚ùå BUILD FAILED: $CRITICAL_COUNT critical vulnerabilities detected"
            echo "build_status=failure" >> $GITHUB_OUTPUT
            echo "FINAL_EXIT_CODE=1" >> $GITHUB_ENV
          else
            echo "‚úÖ BUILD PASSED: No critical vulnerabilities"
            echo "build_status=success" >> $GITHUB_OUTPUT
            echo "FINAL_EXIT_CODE=0" >> $GITHUB_ENV
          fi
      
      - name: Phase 3 ML Analysis
        if: always() && inputs.enable_ml_features && (github.event_name == 'pull_request' || inputs.pr_number)
        continue-on-error: true
        env:
          PHASE3_API_URL: ${{ secrets.PHASE3_API_URL }}
          PHASE3_API_KEY: ${{ secrets.PHASE3_API_KEY }}
        run: |
          echo "ü§ñ Running Phase 3 ML Analysis..."
          
          # Check if Phase 3 API is configured
          if [[ -z "$PHASE3_API_URL" ]] || [[ -z "$PHASE3_API_KEY" ]]; then
            echo "‚ö†Ô∏è Phase 3 API not configured. Skipping ML analysis."
            exit 0
          fi
          
          # Prepare files for ML analysis
          FILES_JSON=$(find . -type f \( -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" \) -not -path "./node_modules/*" -not -path "./.git/*" | head -20 | jq -R -s -c 'split("\n")[:-1] | map({path: ., content: "placeholder"})')
          
          # Get vulnerabilities from previous step
          VULNS_JSON=$(cat vulnerability-details.json | jq -c '.')
          
          # Call Phase 3 API
          ML_RESPONSE=$(curl -s -X POST "${PHASE3_API_URL}/api/analyze-pr" \
            -H "X-API-Key: ${PHASE3_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "{
              \"files\": [],
              \"vulnerabilities\": ${VULNS_JSON}
            }" || echo "{\"error\": \"API call failed\"}")
          
          echo "$ML_RESPONSE" > ml-analysis-results.json
          
          # Check if ML analysis was successful
          if echo "$ML_RESPONSE" | jq -e '.suggestions' > /dev/null 2>&1; then
            echo "‚úÖ ML Analysis completed successfully"
            
            # Extract key insights
            ANOMALY_COUNT=$(echo "$ML_RESPONSE" | jq '.anomalies | length' || echo "0")
            HISTORICAL_MATCHES=$(echo "$ML_RESPONSE" | jq '.historicalContext | length' || echo "0")
            
            echo "üìä ML Insights:"
            echo "- Anomalies detected: $ANOMALY_COUNT"
            echo "- Historical similar incidents: $HISTORICAL_MATCHES"
            echo "- Risk assessment available: $(echo "$ML_RESPONSE" | jq -r '.riskAssessment != null')"
          else
            echo "‚ö†Ô∏è ML Analysis returned no results or failed"
          fi
      
      - name: Upload Security Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-analysis-report
          path: |
            security-report.json
            vulnerability-details.json
            ml-analysis-results.json
          retention-days: 30
      
      - name: Post Summary Comment
        if: always() && (github.event_name == 'pull_request' || inputs.pr_number)
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require('fs');
            
            let report;
            try {
              report = JSON.parse(fs.readFileSync('security-report.json', 'utf8'));
            } catch (error) {
              console.error('Failed to read report:', error);
              return;
            }
            
            let mlResults = null;
            try {
              if (fs.existsSync('ml-analysis-results.json')) {
                mlResults = JSON.parse(fs.readFileSync('ml-analysis-results.json', 'utf8'));
              }
            } catch (error) {
              console.error('Failed to read ML results:', error);
            }
            
            const { summary } = report;
            
            // Create status emoji based on severity
            let statusEmoji = '‚úÖ';
            let statusText = 'PASSED';
            if (summary.critical > 0) {
              statusEmoji = '‚ùå';
              statusText = 'FAILED';
            } else if (summary.high > 10) {
              statusEmoji = '‚ö†Ô∏è';
              statusText = 'WARNING';
            }
            
            // Build ML insights section
            let mlInsights = '';
            if (mlResults && !mlResults.error) {
              const anomalyCount = mlResults.anomalies?.length || 0;
              const historicalCount = mlResults.historicalContext?.length || 0;
              const hasRiskAssessment = !!mlResults.riskAssessment;
              
              mlInsights = `
            ### üß† **Phase 3 ML Analysis**
            ${summary.mlFeaturesEnabled ? '‚úÖ **Enabled**' : '‚ùå **Disabled**'}
            
            ${summary.mlFeaturesEnabled && mlResults ? `
            #### üìä **ML-Powered Insights**:
            - **Anomalies Detected**: ${anomalyCount} unusual patterns found
            - **Historical Context**: ${historicalCount} similar incidents from Security Time Machine
            - **Risk Assessment**: ${hasRiskAssessment ? '‚úÖ Available' : '‚ùå Not available'}
            - **AI Suggestions**: Enhanced fix recommendations powered by context-aware ML
            
            ${anomalyCount > 0 ? `
            ‚ö†Ô∏è **Anomaly Alert**: The ML system detected ${anomalyCount} unusual security patterns that may indicate:
            - Zero-day vulnerabilities
            - Novel attack vectors
            - Business logic flaws
            ` : ''}
            
            ${historicalCount > 0 ? `
            üìö **Historical Insights**: Found ${historicalCount} similar security incidents in the organization's history.
            These can provide valuable context for fixing the current vulnerabilities.
            ` : ''}
            ` : '‚ö†Ô∏è ML analysis unavailable. Configure PHASE3_API_URL and PHASE3_API_KEY for enhanced detection.'}`;
            }
            
            const comment = `## ${statusEmoji} **Security Paranoia Bot Analysis Report**
            
            **Status**: ${statusText} | **Analysis Time**: ${new Date().toISOString()}
            
            ### üìä **Vulnerability Summary**
            
            | Severity | Count | Status |
            |----------|-------|--------|
            | üî¥ **Critical** | **${summary.critical}** | ${summary.critical > 0 ? '‚ùå Action Required' : '‚úÖ None Found'} |
            | üü† **High** | **${summary.high}** | ${summary.high > 10 ? '‚ö†Ô∏è Review Recommended' : '‚úÖ Acceptable'} |
            | üü° **Medium** | **${summary.medium}** | ${summary.medium > 0 ? 'üìù Consider Fixing' : '‚úÖ None Found'} |
            | **TOTAL** | **${summary.totalVulnerabilities}** | **${summary.totalVulnerabilities} vulnerabilities detected** |
            
            ### ü§ñ **AI-Enhanced Analysis**
            ${summary.aiAnalysisEnabled ? '‚úÖ **Enabled** - Gemini AI provided context-aware analysis and fix suggestions' : '‚ùå **Disabled** - Pattern-based detection only'}
            
            ${mlInsights}
            
            ### üìã **Next Steps**
            
            ${summary.critical > 0 ? `
            #### ‚ùå **IMMEDIATE ACTION REQUIRED**
            - **${summary.critical} critical vulnerabilities** must be fixed before deployment
            - Review inline comments on specific lines for detailed fixes
            - Re-run analysis after fixes are applied
            ` : ''}
            
            ${summary.high > 10 ? `
            #### ‚ö†Ô∏è **HIGH SEVERITY ISSUES**
            - **${summary.high} high-severity vulnerabilities** detected
            - Check inline code comments for specific remediation steps
            - Consider addressing before production deployment
            ` : ''}
            
            ### üîç **Detailed Analysis**
            
            The Security Paranoia Bot has added **inline comments** on every vulnerable line of code with:
            - Specific vulnerability description
            - Security impact explanation
            - Recommended fix with code examples
            ${mlResults && !mlResults.error ? '- ML-enhanced suggestions based on historical data' : ''}
            
            Please review all inline comments in the "Files changed" tab above.
            
            ---
            
            > ü§ñ **Security Paranoia Bot** powered by SiYuan Organization
            > 
            > üìä **Analysis Details**: ${summary.totalVulnerabilities} vulnerabilities found with line-by-line annotations
            > ${summary.mlFeaturesEnabled ? 'üß† **ML Features**: Phase 3 ML analysis active' : ''}
            > 
            > üîó **View Full Report**: Check the workflow artifacts for detailed analysis
            `;
            
            // Post summary comment
            const issueNumber = context.payload.pull_request?.number || 
                               parseInt('${{ inputs.pr_number }}') || 
                               context.issue.number;
            
            if (issueNumber) {
              await github.rest.issues.createComment({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
      
      - name: Post Comprehensive Inline Comments
        if: always() && (github.event_name == 'pull_request' || inputs.pr_number)
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require('fs');
            
            // Read vulnerability details
            let vulnerabilities;
            try {
              vulnerabilities = JSON.parse(fs.readFileSync('vulnerability-details.json', 'utf8'));
            } catch (error) {
              console.error('Failed to read vulnerability details:', error);
              return;
            }
            
            // Read ML results if available
            let mlResults = null;
            try {
              if (fs.existsSync('ml-analysis-results.json')) {
                mlResults = JSON.parse(fs.readFileSync('ml-analysis-results.json', 'utf8'));
              }
            } catch (error) {
              console.error('Failed to read ML results:', error);
            }
            
            const prNumber = context.payload.pull_request?.number || parseInt('${{ inputs.pr_number }}');
            if (!prNumber) {
              console.log('No PR number found');
              return;
            }
            
            // Get the PR details to find the commit SHA
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const commitSha = pr.data.head.sha;
            
            // Get PR files to check which files are part of the diff
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100
            });
            
            const prFiles = new Set(files.data.map(f => f.filename));
            
            // Comment templates with ML enhancements
            const commentTemplates = [
              {
                template: (vuln, mlSuggestion) => `### üö® ${vuln.severity.toUpperCase()} SECURITY ALERT: ${vuln.type}
            
            **Issue in line above:**
            ${vuln.message}
            
            **Security Impact:** ${vuln.severity === 'critical' ? 'This critical vulnerability can lead to complete system compromise.' : vuln.severity === 'high' ? 'This high-risk vulnerability can expose sensitive data or functionality.' : 'This vulnerability may have moderate security impact.'}
            
            **Required Fix:**
            \`\`\`javascript
            ${vuln.fix}
            \`\`\`
            
            ${mlSuggestion ? `
            **üß† ML-Enhanced Suggestion:**
            ${mlSuggestion}
            ` : ''}
            
            ${vuln.severity === 'critical' ? '‚ö†Ô∏è **URGENT:** This must be addressed before production deployment!' : vuln.severity === 'high' ? '‚ö†Ô∏è **IMPORTANT:** Please prioritize fixing this security issue.' : 'üìù **NOTE:** Consider addressing this security concern.'}`,
                weight: 4
              },
              {
                template: (vuln, mlSuggestion) => `## ‚õî Security Vulnerability Found: ${vuln.type}
            
            **Severity Level:** ${vuln.severity.charAt(0).toUpperCase() + vuln.severity.slice(1)}
            
            **Problem with the line above:**
            ${vuln.message}
            
            **Remediation:**
            \`\`\`javascript
            ${vuln.fix}
            \`\`\`
            
            ${mlSuggestion ? `
            **ü§ñ AI-Powered Insight:**
            ${mlSuggestion}
            ` : ''}
            
            This security flaw requires ${vuln.severity === 'critical' ? 'immediate' : vuln.severity === 'high' ? 'prompt' : 'eventual'} attention to prevent potential exploitation.`,
                weight: 3
              }
            ];
            
            // Function to get ML suggestion for a vulnerability
            function getMLSuggestion(vuln, file) {
              if (!mlResults || !mlResults.suggestions) return null;
              
              // Find matching suggestion
              const suggestions = mlResults.suggestions.find(s => 
                s.vulnerabilityId === `${file}-${vuln.line}` || 
                (s.file === file && s.line === vuln.line)
              );
              
              if (suggestions && suggestions.suggestions && suggestions.suggestions.length > 0) {
                return suggestions.suggestions[0].description || suggestions.suggestions[0];
              }
              
              return null;
            }
            
            // Function to get random template based on weights
            function getRandomTemplate() {
              const totalWeight = commentTemplates.reduce((sum, t) => sum + t.weight, 0);
              let random = Math.random() * totalWeight;
              
              for (const template of commentTemplates) {
                random -= template.weight;
                if (random <= 0) {
                  return template.template;
                }
              }
              return commentTemplates[0].template;
            }
            
            // Process ALL vulnerabilities as requested by user
            const allComments = [];
            
            for (const [filename, fileVulns] of Object.entries(vulnerabilities)) {
              if (!prFiles.has(filename)) {
                console.log(`Skipping ${filename} - not part of PR`);
                continue;
              }
              
              // Include ALL vulnerabilities (critical, high, and medium)
              for (const vuln of fileVulns) {
                const template = getRandomTemplate();
                const mlSuggestion = getMLSuggestion(vuln, filename);
                const comment = template(vuln, mlSuggestion);
                
                // Comment AFTER the vulnerable line (line + 1) to provide context about what was just seen
                allComments.push({
                  path: filename,
                  line: vuln.line + 1, // Position comment AFTER the vulnerable line
                  side: 'RIGHT',
                  body: comment,
                  vuln: vuln,
                  originalLine: vuln.line // Keep track of original line for logging
                });
              }
            }
            
            const totalComments = allComments.length;
            console.log(`Posting ${totalComments} vulnerability comments (ALL detected vulnerabilities as requested)`);
            console.log('Comments will be positioned AFTER each vulnerable line (not on the line itself)');
            if (mlResults && !mlResults.error) {
              console.log('ML-enhanced suggestions are available and will be included');
            }
            
            if (totalComments === 0) {
              console.log('No vulnerabilities found in PR files');
              return;
            }
            
            // Process comments with longer delays and smaller batches to avoid abuse detection
            const BATCH_SIZE = 5; // Smaller batches
            const DELAY_MS = 5000; // 5 second delay between comments to avoid rate limits
            let successfulComments = 0;
            let failedComments = 0;
            
            // Function to sleep
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            
            console.log('Posting ALL vulnerability comments with anti-abuse delays...');
            console.log(`Using ${DELAY_MS}ms delays between batches of ${BATCH_SIZE} comments`);
            
            // Process in batches with delays
            for (let i = 0; i < allComments.length; i += BATCH_SIZE) {
              const batch = allComments.slice(i, i + BATCH_SIZE);
              const batchNumber = Math.floor(i / BATCH_SIZE) + 1;
              const totalBatches = Math.ceil(allComments.length / BATCH_SIZE);
              
              console.log(`\nüìù Processing batch ${batchNumber}/${totalBatches} (${batch.length} comments)`);
              
              // Process comments in the batch concurrently
              const batchPromises = batch.map(async (comment, index) => {
                try {
                  // Add small stagger within batch (500ms between each comment in batch)
                  if (index > 0) {
                    await sleep(500);
                  }
                  
                  await github.rest.pulls.createReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    commit_id: commitSha,
                    path: comment.path,
                    line: comment.line,
                    side: comment.side,
                    body: comment.body
                  });
                  
                  const commentNumber = i + index + 1;
                  console.log(`‚úÖ [${commentNumber}/${totalComments}] Posted comment after ${comment.path}:${comment.originalLine} (${comment.vuln.severity} ${comment.vuln.type})`);
                  return { success: true, comment };
                  
                } catch (error) {
                  const commentNumber = i + index + 1;
                  console.error(`‚ùå [${commentNumber}/${totalComments}] Failed to comment after ${comment.path}:${comment.originalLine}: ${error.message}`);
                  return { success: false, comment, error: error.message };
                }
              });
              
              // Wait for all comments in the batch to complete
              const results = await Promise.all(batchPromises);
              
              // Count successes and failures
              const batchSuccess = results.filter(r => r.success).length;
              const batchFailed = results.filter(r => !r.success).length;
              
              successfulComments += batchSuccess;
              failedComments += batchFailed;
              
              console.log(`Batch ${batchNumber} complete: ${batchSuccess} successful, ${batchFailed} failed`);
              
              // Add delay between batches (except for the last batch)
              if (i + BATCH_SIZE < allComments.length) {
                console.log(`‚è≥ Waiting ${DELAY_MS}ms before next batch to avoid rate limits...`);
                await sleep(DELAY_MS);
              }
            }
            
            // Final summary
            console.log('\nüìä Complete Vulnerability Comments Summary:');
            console.log(`‚úÖ Successfully posted: ${successfulComments}`);
            console.log(`‚ùå Failed to post: ${failedComments}`);
            console.log(`üìù Total vulnerabilities processed: ${totalComments}`);
            
            const successRate = totalComments > 0 ? (successfulComments / totalComments * 100).toFixed(1) : 0;
            console.log(`üìà Success rate: ${successRate}%`);
            
            if (successfulComments > 0) {
              console.log('\nüéØ Successfully posted inline comments AFTER all detected vulnerable lines!');
              if (mlResults && !mlResults.error) {
                console.log('üß† ML-enhanced suggestions were included where available');
              }
            } else if (failedComments > 0) {
              console.log('\n‚ö†Ô∏è All vulnerability comments failed to post. This might be due to abuse detection or API limits.');
              console.log('Consider running the workflow again later or checking for API rate limits.');
            }
      
      - name: Set Final Exit Code
        if: always()
        run: |
          # Use the exit code determined in the Security Analysis step
          if [[ "${FINAL_EXIT_CODE:-0}" == "1" ]]; then
            echo "‚ùå Workflow failing due to critical vulnerabilities"
            exit 1
          else
            echo "‚úÖ Workflow passing - no critical vulnerabilities"
            exit 0
          fi