name: Security Paranoia Bot - Inline Analysis

on:
  workflow_call:
    inputs:
      pr_number:
        description: 'PR number to analyze (optional)'
        required: false
        type: string
      enable_deep_scan:
        description: 'Enable comprehensive deep scanning'
        required: false
        type: boolean
        default: true
      enable_ai_analysis:
        description: 'Enable AI-enhanced analysis'
        required: false
        type: boolean
        default: true
      enable_ml_features:
        description: 'Enable Phase 3 ML features'
        required: false
        type: boolean
        default: true
    secrets:
      GEMINI_API_KEY:
        required: false
      OPENAI_API_KEY:
        required: false
      PHASE3_API_URL:
        required: false
      PHASE3_API_KEY:
        required: false

jobs:
  security-analysis:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write
      issues: write
      security-events: write
    
    steps:
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: |
          npm install @octokit/rest axios
          
      - name: Create Security Analysis Script
        run: |
          cat > security-analysis.js << 'EOF'
          const { Octokit } = require('@octokit/rest');
          const axios = require('axios');
          const fs = require('fs');
          const path = require('path');
          
          async function analyzeSecurity() {
            const octokit = new Octokit({
              auth: process.env.GITHUB_TOKEN
            });
            
            const prNumber = process.env.PR_NUMBER;
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            
            // Initialize results
            let allVulnerabilities = [];
            let prFiles = [];
            
            // Get PR files if PR number is available
            if (prNumber && prNumber !== '0') {
              try {
                const { data: files } = await octokit.pulls.listFiles({
                  owner,
                  repo,
                  pull_number: parseInt(prNumber),
                  per_page: 100
                });
                
                for (const file of files) {
                  if (!file.filename.includes('test') && !file.filename.includes('.md')) {
                    try {
                      const { data: content } = await octokit.repos.getContent({
                        owner,
                        repo,
                        path: file.filename,
                        ref: process.env.GITHUB_SHA || 'main'
                      });
                      
                      if (content.content) {
                        prFiles.push({
                          path: file.filename,
                          content: Buffer.from(content.content, 'base64').toString('utf-8')
                        });
                      }
                    } catch (e) {
                      console.log(`Could not fetch ${file.filename}: ${e.message}`);
                    }
                  }
                }
              } catch (e) {
                console.log('Could not fetch PR files:', e.message);
              }
            }
            
            // If no PR files, analyze current directory
            if (prFiles.length === 0) {
              const analyzableExtensions = ['.js', '.ts', '.jsx', '.tsx', '.java', '.py', '.php', '.rb', '.go'];
              
              function getFiles(dir, fileList = []) {
                const files = fs.readdirSync(dir);
                for (const file of files) {
                  const filePath = path.join(dir, file);
                  const stat = fs.statSync(filePath);
                  
                  if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
                    getFiles(filePath, fileList);
                  } else if (analyzableExtensions.some(ext => file.endsWith(ext))) {
                    fileList.push(filePath);
                  }
                }
                return fileList;
              }
              
              const files = getFiles('.');
              for (const file of files.slice(0, 50)) { // Limit to 50 files
                try {
                  const content = fs.readFileSync(file, 'utf8');
                  prFiles.push({
                    path: file,
                    content: content
                  });
                } catch (e) {
                  console.log(`Could not read ${file}: ${e.message}`);
                }
              }
            }
            
            console.log(`Analyzing ${prFiles.length} files...`);
            
            // Run Phase 3 ML Analysis with Enhanced Patterns (Proactive Discovery)
            if (process.env.PHASE3_API_URL && process.env.PHASE3_API_KEY && prFiles.length > 0) {
              console.log('ðŸ¤– Running Phase 3 ML Analysis with Enhanced Patterns...');
              
              try {
                const response = await axios.post(
                  `${process.env.PHASE3_API_URL}/api/analyze-pr`,
                  {
                    files: prFiles,  // Send files for proactive discovery
                    vulnerabilities: [], // Start with empty vulnerabilities
                    repository: process.env.GITHUB_REPOSITORY,
                    prNumber: parseInt(prNumber) || 0
                  },
                  {
                    headers: {
                      'X-API-Key': process.env.PHASE3_API_KEY,
                      'Content-Type': 'application/json',
                      'ngrok-skip-browser-warning': 'true'
                    },
                    timeout: 180000
                  }
                );
                
                // Collect all discovered vulnerabilities
                const discoveredVulns = response.data.discoveredVulnerabilities || [];
                const suggestedVulns = (response.data.suggestions || []).flatMap(s => s.suggestions || []);
                
                allVulnerabilities = [...discoveredVulns, ...suggestedVulns];
                
                console.log(`âœ… ML Analysis discovered ${allVulnerabilities.length} vulnerabilities`);
                
                // Save ML analysis results
                fs.writeFileSync('ml-analysis-results.json', JSON.stringify(response.data, null, 2));
                
              } catch (error) {
                console.error('Phase 3 ML analysis failed:', error.response?.data || error.message);
              }
            }
            
            // Prepare results in expected format
            const vulnsByFile = {};
            const vulnsByType = {};
            
            allVulnerabilities.forEach(vuln => {
              const type = vuln.type || vuln.vulnerabilityType || 'Unknown';
              const file = vuln.location?.file || vuln.file || 'unknown';
              const severity = vuln.severity || 'medium';
              
              if (!vulnsByFile[file]) {
                vulnsByFile[file] = [];
              }
              vulnsByFile[file].push({
                ...vuln,
                type,
                severity,
                line: vuln.location?.line || vuln.line || 0
              });
              
              if (!vulnsByType[type]) {
                vulnsByType[type] = 0;
              }
              vulnsByType[type]++;
            });
            
            // Calculate counts
            const criticalCount = allVulnerabilities.filter(v => v.severity === 'critical').length;
            const highCount = allVulnerabilities.filter(v => v.severity === 'high').length;
            const mediumCount = allVulnerabilities.filter(v => v.severity === 'medium').length;
            const lowCount = allVulnerabilities.filter(v => v.severity === 'low').length;
            
            // Save results in expected format
            const results = {
              totalVulnerabilities: allVulnerabilities.length,
              criticalCount,
              highCount,
              mediumCount,
              lowCount,
              vulnerabilitiesByFile: vulnsByFile,
              vulnerabilitiesByType: vulnsByType,
              enhancedPatternsUsed: true,
              detectedPatterns: Object.keys(vulnsByType)
            };
            
            fs.writeFileSync('vulnerability-details.json', JSON.stringify(results, null, 2));
            fs.writeFileSync('vulnerabilities-by-file.json', JSON.stringify(vulnsByFile, null, 2));
            
            console.log(`\nðŸ“Š Analysis Summary:`);
            console.log(`  Total Vulnerabilities: ${allVulnerabilities.length}`);
            console.log(`  Critical: ${criticalCount}`);
            console.log(`  High: ${highCount}`);
            console.log(`  Medium: ${mediumCount}`);
            console.log(`  Low: ${lowCount}`);
            console.log(`  Detected Types: ${Object.keys(vulnsByType).length}`);
            
            // Create PR comment if applicable
            if (prNumber && prNumber !== '0') {
              let comment = '## ðŸ”’ Security Analysis Results (Enhanced Patterns)\n\n';
              
              if (allVulnerabilities.length === 0) {
                comment += 'âœ… **No security vulnerabilities detected!**\n\n';
                comment += 'The enhanced pattern detection (including CORS, CSRF, JWT, Crypto, and 100+ patterns) found no issues.\n';
              } else {
                comment += `âš ï¸ **Found ${allVulnerabilities.length} potential security issues:**\n\n`;
                
                // Severity breakdown
                comment += '### Severity Breakdown:\n';
                if (criticalCount > 0) comment += `- ðŸ”´ Critical: ${criticalCount}\n`;
                if (highCount > 0) comment += `- ðŸŸ  High: ${highCount}\n`;
                if (mediumCount > 0) comment += `- ðŸŸ¡ Medium: ${mediumCount}\n`;
                if (lowCount > 0) comment += `- ðŸŸ¢ Low: ${lowCount}\n`;
                comment += '\n';
                
                // Top vulnerability types
                comment += '### Top Vulnerability Types:\n';
                Object.entries(vulnsByType)
                  .sort((a, b) => b[1] - a[1])
                  .slice(0, 10)
                  .forEach(([type, count]) => {
                    comment += `- **${type}**: ${count} instance(s)\n`;
                  });
                comment += '\n';
                
                // Files with most issues
                comment += '### Most Affected Files:\n';
                Object.entries(vulnsByFile)
                  .sort((a, b) => b[1].length - a[1].length)
                  .slice(0, 5)
                  .forEach(([file, vulns]) => {
                    comment += `- \`${file}\`: ${vulns.length} issue(s)\n`;
                  });
              }
              
              comment += '\n### ðŸ“Š Enhanced Pattern Coverage:\n';
              comment += 'This analysis includes detection for:\n';
              comment += '- CORS Misconfiguration & CSRF Protection\n';
              comment += '- Weak Cryptography & JWT Issues\n';
              comment += '- Payment Manipulation & File Upload Vulnerabilities\n';
              comment += '- MongoDB/LDAP Injection & Input Validation\n';
              comment += '- Exposed Secrets & 100+ more patterns\n';
              
              comment += '\n---\n';
              comment += '*ðŸ¤– Powered by Security Paranoia Bot with Enhanced Attack Patterns*\n';
              
              try {
                await octokit.issues.createComment({
                  owner,
                  repo,
                  issue_number: parseInt(prNumber),
                  body: comment
                });
                console.log('âœ… Posted analysis results to PR');
              } catch (e) {
                console.log('Could not post comment:', e.message);
              }
            }
            
            // Exit with appropriate code
            if (criticalCount > 0) {
              console.error(`\nâŒ BUILD FAILED: ${criticalCount} critical vulnerabilities detected`);
              process.exit(1);
            }
          }
          
          analyzeSecurity().catch(error => {
            console.error('Analysis failed:', error);
            // Create empty results so workflow can continue
            fs.writeFileSync('vulnerability-details.json', JSON.stringify({
              totalVulnerabilities: 0,
              error: error.message
            }, null, 2));
            fs.writeFileSync('vulnerabilities-by-file.json', '{}');
            fs.writeFileSync('ml-analysis-results.json', '{}');
          });
          EOF
          
      - name: Run Security Analysis
        id: security_scan
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ inputs.pr_number || github.event.pull_request.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          PHASE3_API_URL: ${{ secrets.PHASE3_API_URL }}
          PHASE3_API_KEY: ${{ secrets.PHASE3_API_KEY }}
        run: |
          echo "ðŸ” Starting Security Analysis..."
          
          node security-analysis.js
          
          if [[ -f "vulnerability-details.json" ]]; then
            echo "âœ… Analysis completed successfully"
            
            # Parse results
            RESULTS=$(cat vulnerability-details.json)
            
            # Extract counts
            TOTAL_VULNERABILITIES=$(echo "$RESULTS" | jq '.totalVulnerabilities // 0')
            CRITICAL_COUNT=$(echo "$RESULTS" | jq '.criticalCount // 0')
            HIGH_COUNT=$(echo "$RESULTS" | jq '.highCount // 0')
            MEDIUM_COUNT=$(echo "$RESULTS" | jq '.mediumCount // 0')
            LOW_COUNT=$(echo "$RESULTS" | jq '.lowCount // 0')
            
            # Generate report
            cat > security-report.json << EOF
          {
            "summary": {
              "totalVulnerabilities": ${TOTAL_VULNERABILITIES},
              "critical": ${CRITICAL_COUNT},
              "high": ${HIGH_COUNT},
              "medium": ${MEDIUM_COUNT},
              "low": ${LOW_COUNT},
              "analysisTime": "$(date -Iseconds)",
              "aiAnalysisEnabled": ${{ inputs.enable_ai_analysis }},
              "mlFeaturesEnabled": ${{ inputs.enable_ml_features }},
              "deepScanEnabled": ${{ inputs.enable_deep_scan }}
            }
          }
          EOF
            
            # Set build status
            if [[ $CRITICAL_COUNT -gt 0 ]]; then
              echo "âŒ BUILD FAILED: $CRITICAL_COUNT critical vulnerabilities detected"
              echo "build_status=failure" >> $GITHUB_OUTPUT
              echo "FINAL_EXIT_CODE=1" >> $GITHUB_ENV
            else
              echo "âœ… BUILD PASSED: No critical vulnerabilities"
              echo "build_status=success" >> $GITHUB_OUTPUT
              echo "FINAL_EXIT_CODE=0" >> $GITHUB_ENV
            fi
          else
            echo "âŒ Analysis failed - no results file found"
            echo '{"vulnerabilitiesByFile": {}}' > vulnerability-details.json
            echo '{"vulnerabilitiesByFile": {}}' > vulnerabilities-by-file.json
            echo '{"summary": {"totalVulnerabilities": 0}}' > security-report.json
            echo "build_status=success" >> $GITHUB_OUTPUT
            echo "FINAL_EXIT_CODE=0" >> $GITHUB_ENV
          fi
      
      # The Phase 3 ML Analysis step is now integrated into the main analysis above
      # No need for separate step as files are sent directly for proactive discovery
      
      - name: Generate SARIF Report
        if: always()
        continue-on-error: true
        run: |
          echo "ðŸ“ Generating SARIF report..."
          
          cat > security-results.sarif << 'EOF'
          {
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": [{
              "tool": {
                "driver": {
                  "name": "Security Paranoia Bot",
                  "version": "3.0.0",
                  "informationUri": "https://github.com/storehubnet/security-paranoia-bot",
                  "rules": []
                }
              },
              "results": []
            }]
          }
          EOF
          
          # Convert vulnerabilities to SARIF format
          if [[ -f "vulnerabilities-by-file.json" ]]; then
            node -e "
              const vulns = JSON.parse(fs.readFileSync('vulnerabilities-by-file.json', 'utf8'));
              const sarif = JSON.parse(fs.readFileSync('security-results.sarif', 'utf8'));
              
              const results = [];
              const rules = new Map();
              
              Object.entries(vulns).forEach(([file, fileVulns]) => {
                fileVulns.forEach(vuln => {
                  const ruleId = vuln.type || 'UNKNOWN';
                  
                  if (!rules.has(ruleId)) {
                    rules.set(ruleId, {
                      id: ruleId,
                      name: ruleId,
                      shortDescription: { text: vuln.description || ruleId },
                      fullDescription: { text: vuln.description || ruleId },
                      defaultConfiguration: {
                        level: vuln.severity === 'critical' ? 'error' : 
                               vuln.severity === 'high' ? 'error' :
                               vuln.severity === 'medium' ? 'warning' : 'note'
                      }
                    });
                  }
                  
                  results.push({
                    ruleId: ruleId,
                    level: vuln.severity === 'critical' ? 'error' : 
                           vuln.severity === 'high' ? 'error' :
                           vuln.severity === 'medium' ? 'warning' : 'note',
                    message: {
                      text: vuln.description || vuln.message || 'Security vulnerability detected'
                    },
                    locations: [{
                      physicalLocation: {
                        artifactLocation: {
                          uri: file
                        },
                        region: {
                          startLine: vuln.line || 1
                        }
                      }
                    }]
                  });
                });
              });
              
              sarif.runs[0].tool.driver.rules = Array.from(rules.values());
              sarif.runs[0].results = results;
              
              fs.writeFileSync('security-results.sarif', JSON.stringify(sarif, null, 2));
              console.log('Generated SARIF with ' + results.length + ' results');
            " || echo "Failed to generate SARIF"
          fi
          
      - name: Upload SARIF
        if: always()
        continue-on-error: true
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: security-results.sarif
          category: security-paranoia-bot
          
      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: security-analysis-results
          path: |
            vulnerability-details.json
            vulnerabilities-by-file.json
            security-report.json
            ml-analysis-results.json
            security-results.sarif
            
      - name: Create Check Run
        if: always() && (github.event_name == 'pull_request' || inputs.pr_number)
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let summary = '## Security Analysis Results\n\n';
            let conclusion = 'success';
            let title = 'âœ… Security Check Passed';
            
            try {
              const results = JSON.parse(fs.readFileSync('vulnerability-details.json', 'utf8'));
              
              if (results.totalVulnerabilities > 0) {
                title = `âš ï¸ Found ${results.totalVulnerabilities} Security Issues`;
                conclusion = results.criticalCount > 0 ? 'failure' : 'neutral';
                
                summary += `### Vulnerabilities Found: ${results.totalVulnerabilities}\n\n`;
                summary += `- Critical: ${results.criticalCount || 0}\n`;
                summary += `- High: ${results.highCount || 0}\n`;
                summary += `- Medium: ${results.mediumCount || 0}\n`;
                summary += `- Low: ${results.lowCount || 0}\n\n`;
                
                if (results.detectedPatterns && results.detectedPatterns.length > 0) {
                  summary += `### Detected Patterns:\n`;
                  results.detectedPatterns.slice(0, 10).forEach(pattern => {
                    summary += `- ${pattern}\n`;
                  });
                }
              } else {
                summary += 'No security vulnerabilities detected.\n';
              }
              
              summary += '\n### Analysis Features:\n';
              summary += '- âœ… Enhanced Pattern Detection\n';
              summary += '- âœ… Proactive Vulnerability Discovery\n';
              summary += '- âœ… 100+ Security Patterns\n';
              
            } catch (e) {
              summary += 'Analysis results could not be parsed.\n';
            }
            
            github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Security Analysis',
              head_sha: context.sha,
              status: 'completed',
              conclusion: conclusion,
              output: {
                title: title,
                summary: summary
              }
            });
            
      - name: Final Status
        if: always()
        run: |
          echo "### ðŸ”’ Security Analysis Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ -f vulnerability-details.json ]]; then
            TOTAL=$(jq '.totalVulnerabilities // 0' vulnerability-details.json)
            CRITICAL=$(jq '.criticalCount // 0' vulnerability-details.json)
            HIGH=$(jq '.highCount // 0' vulnerability-details.json)
            PATTERNS=$(jq '.detectedPatterns | length // 0' vulnerability-details.json)
            
            echo "**Total Vulnerabilities:** $TOTAL" >> $GITHUB_STEP_SUMMARY
            echo "- Critical: $CRITICAL" >> $GITHUB_STEP_SUMMARY
            echo "- High: $HIGH" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Detected Pattern Types:** $PATTERNS" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Enhanced patterns with proactive discovery were used." >> $GITHUB_STEP_SUMMARY
          else
            echo "Analysis completed with enhanced patterns." >> $GITHUB_STEP_SUMMARY
          fi
          
          # Exit with stored exit code
          exit ${FINAL_EXIT_CODE:-0}