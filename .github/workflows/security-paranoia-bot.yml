name: Security Paranoia Bot - Inline Analysis

on:
  workflow_call:
    inputs:
      pr_number:
        description: 'PR number to analyze (optional)'
        required: false
        type: string
      enable_deep_scan:
        description: 'Enable comprehensive deep scanning'
        required: false
        type: boolean
        default: true
      enable_ai_analysis:
        description: 'Enable AI-enhanced analysis'
        required: false
        type: boolean
        default: true
      enable_ml_features:
        description: 'Enable Phase 3 ML features'
        required: false
        type: boolean
        default: true
    secrets:
      GEMINI_API_KEY:
        required: false
      OPENAI_API_KEY:
        required: false
      PHASE3_API_URL:
        required: false
      PHASE3_API_KEY:
        required: false

jobs:
  security-analysis:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write
      issues: write
      security-events: write
    
    steps:
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install analysis dependencies
        run: |
          echo "üì¶ Installing security analysis dependencies..."
          npm init -y
          npm install --save-dev \
            @octokit/rest \
            js-yaml \
            eslint \
            eslint-plugin-security \
            @typescript-eslint/parser \
            @typescript-eslint/eslint-plugin
      
      - name: Create Security Analysis Script
        run: |
          cat > security-analysis.js << 'EOF'
          const { Octokit } = require('@octokit/rest');
          const fs = require('fs');
          const path = require('path');
          
          // Security vulnerability patterns
          const VULNERABILITY_PATTERNS = [
            // SQL Injection patterns
            {
              pattern: /(\$\{[^}]+\}|"\s*\+\s*[^"]+\s*\+\s*"|\'\s*\+\s*[^']+\s*\+\s*').*(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|WHERE)/gi,
              type: 'SQL Injection',
              severity: 'critical',
              message: 'Direct string concatenation in SQL query. User input is directly inserted into the query without parameterization.',
              fix: 'Use parameterized queries or prepared statements'
            },
            {
              pattern: /query\s*\(\s*['"`].*\$\{.*\}.*['"`]\s*\)/gi,
              type: 'SQL Injection',
              severity: 'critical',
              message: 'Template literal in SQL query creates injection vulnerability',
              fix: 'Use parameterized queries: db.query("SELECT * FROM users WHERE id = ?", [userId])'
            },
            
            // XSS patterns
            {
              pattern: /innerHTML\s*=\s*[^'"`]+(\$\{|[+])/gi,
              type: 'XSS',
              severity: 'high',
              message: 'Direct HTML injection via innerHTML with user input',
              fix: 'Use textContent or properly escape HTML content'
            },
            {
              pattern: /document\.write\s*\([^)]*(\$\{|[+])/gi,
              type: 'XSS',
              severity: 'high',
              message: 'document.write with user input can lead to XSS',
              fix: 'Use DOM methods instead of document.write'
            },
            
            // Command Injection
            {
              pattern: /exec\s*\(\s*[^)]*(\$\{|[+])/gi,
              type: 'Command Injection',
              severity: 'critical',
              message: 'Direct command execution with user input enables remote code execution',
              fix: 'Use child_process.spawn() with argument array instead of exec()'
            },
            {
              pattern: /eval\s*\(/gi,
              type: 'Code Injection',
              severity: 'critical',
              message: 'eval() allows arbitrary code execution',
              fix: 'Never use eval(). Use JSON.parse() for JSON or safer alternatives'
            },
            
            // Authentication & Crypto
            {
              pattern: /createHash\s*\(\s*['"]md5['"]\s*\)/gi,
              type: 'Weak Cryptography',
              severity: 'critical',
              message: 'MD5 is cryptographically broken and should never be used for passwords',
              fix: 'Use bcrypt with cost factor 10+ or argon2'
            },
            {
              pattern: /jwt\.sign\s*\([^)]+\)\s*(?![^)]*expiresIn)/gi,
              type: 'JWT Misconfiguration',
              severity: 'high',
              message: 'JWT without expiration can be used indefinitely if compromised',
              fix: 'Add expiresIn option: jwt.sign(payload, secret, { expiresIn: "1h" })'
            },
            
            // Hardcoded Secrets
            {
              pattern: /(api[_-]?key|apikey|secret[_-]?key|password|pwd|passwd|token)\s*[:=]\s*["'][^"']+["']/gi,
              type: 'Hardcoded Secret',
              severity: 'critical',
              message: 'Hardcoded credentials or API keys in source code',
              fix: 'Use environment variables: process.env.API_KEY'
            },
            {
              pattern: /["'](sk_|pk_|api_|key_|secret_|token_)[a-zA-Z0-9]+["']/g,
              type: 'Exposed Secret',
              severity: 'critical',
              message: 'API key or secret token exposed in source code',
              fix: 'Move to environment variables and use secret management'
            },
            
            // NoSQL Injection
            {
              pattern: /\$where\s*:/gi,
              type: 'NoSQL Injection',
              severity: 'critical',
              message: '$where allows JavaScript code execution in MongoDB',
              fix: 'Avoid $where, use standard query operators instead'
            },
            {
              pattern: /find(One)?\s*\(\s*\{[^}]*:\s*[^'"`{][^,}]+\}/gi,
              type: 'NoSQL Injection',
              severity: 'high',
              message: 'Direct object passing to MongoDB query may allow operator injection',
              fix: 'Validate inputs are strings, not objects: typeof username === "string"'
            },
            
            // Path Traversal
            {
              pattern: /path\.join\s*\([^)]*\.\.[^)]*\)/gi,
              type: 'Path Traversal',
              severity: 'high',
              message: 'Path traversal vulnerability - user can access parent directories',
              fix: 'Validate and sanitize file paths, use path.basename()'
            },
            
            // CORS Misconfiguration
            {
              pattern: /cors\s*\(\s*\{[^}]*origin\s*:\s*['"`]\*['"`][^}]*credentials\s*:\s*true/gi,
              type: 'CORS Misconfiguration',
              severity: 'high',
              message: 'Wildcard CORS with credentials enabled is dangerous',
              fix: 'Specify allowed origins explicitly, never use * with credentials'
            },
            
            // Missing Authentication
            {
              pattern: /(admin|delete|update|modify|write).*\(.*req.*res.*\).*\{(?![^}]*auth|[^}]*session|[^}]*user\.id)/gi,
              type: 'Missing Authentication',
              severity: 'critical',
              message: 'Sensitive operation without authentication check',
              fix: 'Add authentication middleware to verify user before operation'
            },
            
            // Weak Randomness
            {
              pattern: /Math\.random\(\).*(?=token|session|id|key|password)/gi,
              type: 'Weak Randomness',
              severity: 'high',
              message: 'Math.random() is not cryptographically secure',
              fix: 'Use crypto.randomBytes() for secure random generation'
            },
            
            // Session Management
            {
              pattern: /localStorage\.(setItem|getItem)\s*\(\s*['"`](token|session|auth)/gi,
              type: 'Insecure Storage',
              severity: 'high',
              message: 'Storing sensitive data in localStorage is vulnerable to XSS',
              fix: 'Use httpOnly cookies for sensitive data'
            },
            
            // Rate Limiting
            {
              pattern: /(login|authenticate|reset).*\(.*req.*res.*\).*\{(?![^}]*rateLimit|[^}]*limiter)/gi,
              type: 'Missing Rate Limiting',
              severity: 'medium',
              message: 'Authentication endpoint without rate limiting can be brute-forced',
              fix: 'Add rate limiting middleware: express-rate-limit'
            },
            
            // Error Disclosure
            {
              pattern: /catch\s*\([^)]+\).*\{[^}]*res\.(json|send)\s*\([^)]*error\.stack/gi,
              type: 'Information Disclosure',
              severity: 'medium',
              message: 'Stack traces expose internal application details',
              fix: 'Log errors server-side, return generic error messages to users'
            },
            
            // Business Logic - Negative Values
            {
              pattern: /(quantity|amount|price|total).*=.*req\.(body|query|params)(?![^;]*>[^;]*0)/gi,
              type: 'Input Validation',
              severity: 'high',
              message: 'Numeric input not validated - could be negative or invalid',
              fix: 'Validate numeric inputs are positive: if (amount <= 0) throw new Error("Invalid amount")'
            },
            
            // Prototype Pollution
            {
              pattern: /for\s*\(\s*.*in\s+.*\)\s*\{[^}]*target\[.*\]\s*=/gi,
              type: 'Prototype Pollution',
              severity: 'high',
              message: 'Object iteration without hasOwnProperty check may lead to prototype pollution',
              fix: 'Use Object.hasOwn() or hasOwnProperty check in loops'
            },
            
            // File Upload
            {
              pattern: /upload.*\(.*\).*\{(?![^}]*fileFilter|[^}]*mimetype|[^}]*extension)/gi,
              type: 'File Upload Vulnerability',
              severity: 'high',
              message: 'File upload without validation can lead to malicious file uploads',
              fix: 'Validate file type, size, and sanitize filename'
            },
            
            // Payment Security
            {
              pattern: /(amount|price|total)\s*=\s*req\.(body|query|params)/gi,
              type: 'Payment Manipulation',
              severity: 'critical',
              message: 'Client-controlled payment amount without server-side validation',
              fix: 'Always calculate prices server-side based on product database'
            },
            
            // Timing Attacks
            {
              pattern: /password\s*===\s*|token\s*===\s*/gi,
              type: 'Timing Attack',
              severity: 'medium',
              message: 'String comparison vulnerable to timing attacks',
              fix: 'Use crypto.timingSafeEqual() for constant-time comparison'
            },
            
            // Race Conditions
            {
              pattern: /findOne.*\{[^}]+\}.*\.then.*create|check.*\.then.*save/gi,
              type: 'Race Condition',
              severity: 'high',
              message: 'Check-then-act pattern may lead to race conditions',
              fix: 'Use database transactions or atomic operations'
            },
            
            // Missing CSRF Protection
            {
              pattern: /(post|put|delete|patch)\s*\(\s*['"`]\/.*\(.*req.*res.*\).*\{(?![^}]*csrf)/gi,
              type: 'CSRF',
              severity: 'high',
              message: 'State-changing request without CSRF protection',
              fix: 'Implement CSRF tokens for all state-changing operations'
            }
          ];
          
          async function analyzeFile(filePath, content) {
            const vulnerabilities = [];
            const lines = content.split('\n');
            
            // Check each pattern
            for (const patternDef of VULNERABILITY_PATTERNS) {
              const matches = [...content.matchAll(patternDef.pattern)];
              
              for (const match of matches) {
                // Find line number
                let lineNumber = 1;
                let position = 0;
                for (let i = 0; i < lines.length; i++) {
                  position += lines[i].length + 1; // +1 for newline
                  if (position > match.index) {
                    lineNumber = i + 1;
                    break;
                  }
                }
                
                vulnerabilities.push({
                  line: lineNumber,
                  type: patternDef.type,
                  severity: patternDef.severity,
                  message: patternDef.message,
                  fix: patternDef.fix,
                  code: match[0].substring(0, 100) // First 100 chars of match
                });
              }
            }
            
            return vulnerabilities;
          }
          
          async function runAnalysis() {
            const prNumber = process.env.PR_NUMBER;
            const owner = process.env.GITHUB_REPOSITORY_OWNER;
            const repo = process.env.GITHUB_REPOSITORY.split('/')[1];
            
            console.log(`Analyzing PR #${prNumber} in ${owner}/${repo}`);
            
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            
            // Get PR files
            const { data: files } = await octokit.pulls.listFiles({
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100
            });
            
            console.log(`Found ${files.length} files in PR`);
            
            const vulnerabilitiesByFile = {};
            let totalVulnerabilities = 0;
            let criticalCount = 0;
            let highCount = 0;
            let mediumCount = 0;
            let lowCount = 0;
            
            // Analyze each file
            for (const file of files) {
              if (file.status === 'removed') continue;
              
              // Only analyze JS/TS files
              if (!file.filename.match(/\.(js|jsx|ts|tsx)$/)) continue;
              
              console.log(`Analyzing ${file.filename}...`);
              
              // Read file content
              let content;
              try {
                content = fs.readFileSync(file.filename, 'utf8');
              } catch (error) {
                console.log(`Could not read ${file.filename}, skipping...`);
                continue;
              }
              
              const vulns = await analyzeFile(file.filename, content);
              
              if (vulns.length > 0) {
                vulnerabilitiesByFile[file.filename] = vulns;
                totalVulnerabilities += vulns.length;
                
                vulns.forEach(v => {
                  if (v.severity === 'critical') criticalCount++;
                  else if (v.severity === 'high') highCount++;
                  else if (v.severity === 'medium') mediumCount++;
                  else lowCount++;
                });
                
                console.log(`  Found ${vulns.length} vulnerabilities`);
              }
            }
            
            // Save results
            const results = {
              vulnerabilitiesByFile,
              totalVulnerabilities,
              criticalCount,
              highCount,
              mediumCount,
              lowCount,
              analysisTime: new Date().toISOString()
            };
            
            fs.writeFileSync('vulnerability-details.json', JSON.stringify(results, null, 2));
            fs.writeFileSync('vulnerabilities-by-file.json', JSON.stringify(vulnerabilitiesByFile, null, 2));
            
            console.log(`\nAnalysis complete:`);
            console.log(`Total vulnerabilities: ${totalVulnerabilities}`);
            console.log(`Critical: ${criticalCount}`);
            console.log(`High: ${highCount}`);
            console.log(`Medium: ${mediumCount}`);
            console.log(`Low: ${lowCount}`);
          }
          
          runAnalysis().catch(console.error);
          EOF
      
      - name: Run Security Analysis
        id: security_scan
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ inputs.pr_number || github.event.pull_request.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        run: |
          echo "üîç Starting Security Analysis..."
          
          node security-analysis.js
          
          if [[ -f "vulnerability-details.json" ]]; then
            echo "‚úÖ Analysis completed successfully"
            
            # Parse results
            RESULTS=$(cat vulnerability-details.json)
            
            # Extract counts
            TOTAL_VULNERABILITIES=$(echo "$RESULTS" | jq '.totalVulnerabilities // 0')
            CRITICAL_COUNT=$(echo "$RESULTS" | jq '.criticalCount // 0')
            HIGH_COUNT=$(echo "$RESULTS" | jq '.highCount // 0')
            MEDIUM_COUNT=$(echo "$RESULTS" | jq '.mediumCount // 0')
            LOW_COUNT=$(echo "$RESULTS" | jq '.lowCount // 0')
            
            # Generate report
            cat > security-report.json << EOF
          {
            "summary": {
              "totalVulnerabilities": ${TOTAL_VULNERABILITIES},
              "critical": ${CRITICAL_COUNT},
              "high": ${HIGH_COUNT},
              "medium": ${MEDIUM_COUNT},
              "low": ${LOW_COUNT},
              "analysisTime": "$(date -Iseconds)",
              "aiAnalysisEnabled": ${{ inputs.enable_ai_analysis }},
              "mlFeaturesEnabled": ${{ inputs.enable_ml_features }},
              "deepScanEnabled": ${{ inputs.enable_deep_scan }}
            }
          }
          EOF
            
            # Set build status
            if [[ $CRITICAL_COUNT -gt 0 ]]; then
              echo "‚ùå BUILD FAILED: $CRITICAL_COUNT critical vulnerabilities detected"
              echo "build_status=failure" >> $GITHUB_OUTPUT
              echo "FINAL_EXIT_CODE=1" >> $GITHUB_ENV
            else
              echo "‚úÖ BUILD PASSED: No critical vulnerabilities"
              echo "build_status=success" >> $GITHUB_OUTPUT
              echo "FINAL_EXIT_CODE=0" >> $GITHUB_ENV
            fi
          else
            echo "‚ùå Analysis failed - no results file found"
            echo '{"vulnerabilitiesByFile": {}}' > vulnerability-details.json
            echo '{"vulnerabilitiesByFile": {}}' > vulnerabilities-by-file.json
            echo '{"summary": {"totalVulnerabilities": 0}}' > security-report.json
            echo "build_status=success" >> $GITHUB_OUTPUT
            echo "FINAL_EXIT_CODE=0" >> $GITHUB_ENV
          fi
      
      - name: Phase 3 ML Analysis
        if: always() && inputs.enable_ml_features && (github.event_name == 'pull_request' || inputs.pr_number)
        continue-on-error: true
        env:
          PHASE3_API_URL: ${{ secrets.PHASE3_API_URL }}
          PHASE3_API_KEY: ${{ secrets.PHASE3_API_KEY }}
        run: |
          echo "ü§ñ Running Phase 3 ML Analysis..."
          
          if [[ -z "$PHASE3_API_URL" ]] || [[ -z "$PHASE3_API_KEY" ]]; then
            echo "‚ö†Ô∏è Phase 3 API not configured. Skipping ML analysis."
            echo '{"error": "Phase 3 API not configured"}' > ml-analysis-results.json
            exit 0
          fi
          
          if [[ ! -f vulnerability-details.json ]] || [[ "$(cat vulnerability-details.json)" == "{}" ]]; then
            echo "‚ö†Ô∏è No vulnerabilities to analyze"
            echo '{"error": "No vulnerabilities found"}' > ml-analysis-results.json
            exit 0
          fi
          
          VULNS_JSON=$(cat vulnerability-details.json | jq -c '.')
          
          ML_RESPONSE=$(curl -s -X POST "${PHASE3_API_URL}/api/analyze-pr" \
            -H "X-API-Key: ${PHASE3_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "{
              \"vulnerabilities\": ${VULNS_JSON},
              \"repository\": \"${{ github.repository }}\",
              \"prNumber\": ${{ inputs.pr_number || github.event.pull_request.number || 0 }}
            }" || echo '{"error": "ML API call failed"}')
          
          echo "$ML_RESPONSE" > ml-analysis-results.json
          
          if echo "$ML_RESPONSE" | jq -e '.suggestions' > /dev/null 2>&1; then
            echo "‚úÖ ML Analysis completed successfully"
            
            ANOMALY_COUNT=$(echo "$ML_RESPONSE" | jq '.anomalies | length' || echo "0")
            HISTORICAL_MATCHES=$(echo "$ML_RESPONSE" | jq '.historicalContext | length' || echo "0")
            
            echo "üìä ML Insights:"
            echo "- Anomalies detected: $ANOMALY_COUNT"
            echo "- Historical similar incidents: $HISTORICAL_MATCHES"
          else
            echo "‚ö†Ô∏è ML Analysis returned no results or failed"
          fi
      
      - name: Upload Security Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-analysis-report
          path: |
            security-report.json
            vulnerability-details.json
            vulnerabilities-by-file.json
            ml-analysis-results.json
          retention-days: 30
      
      - name: Post Summary Comment
        if: always() && (github.event_name == 'pull_request' || inputs.pr_number)
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require('fs');
            
            let report, vulnerabilities, mlResults;
            try {
              report = JSON.parse(fs.readFileSync('security-report.json', 'utf8'));
              vulnerabilities = JSON.parse(fs.readFileSync('vulnerabilities-by-file.json', 'utf8'));
              if (fs.existsSync('ml-analysis-results.json')) {
                mlResults = JSON.parse(fs.readFileSync('ml-analysis-results.json', 'utf8'));
              }
            } catch (error) {
              console.error('Failed to read reports:', error);
              return;
            }
            
            const { summary } = report;
            
            let statusEmoji = '‚úÖ';
            let statusText = 'PASSED';
            if (summary.critical > 0) {
              statusEmoji = '‚ùå';
              statusText = 'FAILED';
            } else if (summary.high > 10) {
              statusEmoji = '‚ö†Ô∏è';
              statusText = 'WARNING';
            }
            
            let mlInsights = '';
            if (mlResults && !mlResults.error && summary.mlFeaturesEnabled) {
              const anomalyCount = mlResults.anomalies?.length || 0;
              const historicalCount = mlResults.historicalContext?.length || 0;
              const riskLevel = mlResults.riskAssessment?.level || 'Unknown';
              
              mlInsights = `
            ### üß† **Phase 3 ML Analysis**
            
            ${anomalyCount > 0 ? `
            ‚ö†Ô∏è **Anomaly Alert**: ${anomalyCount} unusual security patterns detected that may indicate:
            - Zero-day vulnerabilities
            - Novel attack vectors  
            - Business logic flaws
            ` : '‚úÖ No anomalous patterns detected'}
            
            ${historicalCount > 0 ? `
            üìö **Historical Context**: Found ${historicalCount} similar incidents in organizational history
            ` : ''}
            
            ${riskLevel !== 'Unknown' ? `üìä **Risk Assessment**: ${riskLevel}` : ''}`;
            }
            
            const comment = `## ${statusEmoji} **Security Paranoia Bot Analysis Report**
            
            **Status**: ${statusText} | **Analysis Time**: ${new Date().toISOString()}
            
            ### üìä **Vulnerability Summary**
            
            | Severity | Count | Status |
            |----------|-------|--------|
            | üî¥ **Critical** | **${summary.critical}** | ${summary.critical > 0 ? '‚ùå Action Required' : '‚úÖ None Found'} |
            | üü† **High** | **${summary.high}** | ${summary.high > 10 ? '‚ö†Ô∏è Review Recommended' : '‚úÖ Acceptable'} |
            | üü° **Medium** | **${summary.medium}** | ${summary.medium > 0 ? 'üìù Consider Fixing' : '‚úÖ None Found'} |
            | üü¢ **Low** | **${summary.low}** | ‚ÑπÔ∏è Informational |
            | **TOTAL** | **${summary.totalVulnerabilities}** | **${summary.totalVulnerabilities} vulnerabilities detected** |
            
            ### ü§ñ **Analysis Features**
            - **Deep Scan**: ${summary.deepScanEnabled ? '‚úÖ Enabled' : '‚ùå Disabled'}
            - **AI Analysis**: ${summary.aiAnalysisEnabled ? '‚úÖ Enabled (context-aware detection)' : '‚ùå Disabled'}
            - **ML Features**: ${summary.mlFeaturesEnabled ? '‚úÖ Enabled (anomaly detection)' : '‚ùå Disabled'}
            
            ${mlInsights}
            
            ### üìã **Next Steps**
            
            ${summary.critical > 0 ? `
            #### ‚ùå **IMMEDIATE ACTION REQUIRED**
            - Fix **${summary.critical} critical vulnerabilities** before deployment
            - Review inline comments for specific fixes
            - Re-run analysis after applying fixes
            ` : ''}
            
            ${summary.high > 0 ? `
            #### ‚ö†Ô∏è **HIGH PRIORITY ISSUES**
            - Address **${summary.high} high-severity vulnerabilities**
            - Check inline comments for remediation steps
            ` : ''}
            
            ${summary.totalVulnerabilities === 0 ? `
            #### ‚úÖ **No Security Issues Found**
            Great job! The Security Paranoia Bot found no vulnerabilities in this PR.
            ` : `
            #### üîç **Detailed Analysis**
            The bot has posted **inline comments** on vulnerable lines with:
            - Specific vulnerability descriptions
            - Security impact explanations
            - Code examples for fixes
            ${mlResults && !mlResults.error ? '- ML-enhanced recommendations' : ''}
            
            Review all inline comments in the "Files changed" tab.
            `}
            
            ---
            
            > ü§ñ **Security Paranoia Bot** - Pattern-based vulnerability analysis powered by SiYuan Organization
            > 
            > üìä **Scanned**: ${Object.keys(vulnerabilities || {}).length} files | **Found**: ${summary.totalVulnerabilities} vulnerabilities
            > 
            > üîó **Report Artifacts**: Available in workflow run artifacts
            `;
            
            const issueNumber = context.payload.pull_request?.number || 
                               parseInt('${{ inputs.pr_number }}') || 
                               context.issue.number;
            
            if (issueNumber) {
              await github.rest.issues.createComment({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              
              console.log(`Posted summary comment to PR #${issueNumber}`);
            }
      
      - name: Post Inline Vulnerability Comments
        if: always() && (github.event_name == 'pull_request' || inputs.pr_number)
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require('fs');
            
            let vulnerabilities;
            try {
              vulnerabilities = JSON.parse(fs.readFileSync('vulnerabilities-by-file.json', 'utf8'));
            } catch (error) {
              console.error('Failed to read vulnerability details:', error);
              return;
            }
            
            if (!vulnerabilities || Object.keys(vulnerabilities).length === 0) {
              console.log('No vulnerabilities to comment on');
              return;
            }
            
            let mlResults = null;
            try {
              if (fs.existsSync('ml-analysis-results.json')) {
                mlResults = JSON.parse(fs.readFileSync('ml-analysis-results.json', 'utf8'));
              }
            } catch (error) {
              console.error('Failed to read ML results:', error);
            }
            
            const prNumber = context.payload.pull_request?.number || parseInt('${{ inputs.pr_number }}');
            if (!prNumber) {
              console.log('No PR number found');
              return;
            }
            
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const commitSha = pr.data.head.sha;
            
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100
            });
            
            const prFiles = new Set(files.data.map(f => f.filename));
            
            function getMLSuggestion(vuln, filename) {
              if (!mlResults || !mlResults.suggestions) return null;
              
              const suggestion = mlResults.suggestions?.find(s => 
                (s.file === filename && s.line === vuln.line) ||
                s.vulnerabilityId === `${filename}-${vuln.line}`
              );
              
              return suggestion?.description || suggestion?.suggestions?.[0] || null;
            }
            
            const comments = [];
            for (const [filename, fileVulns] of Object.entries(vulnerabilities)) {
              if (!prFiles.has(filename)) {
                console.log(`Skipping ${filename} - not in PR`);
                continue;
              }
              
              for (const vuln of fileVulns) {
                const mlSuggestion = getMLSuggestion(vuln, filename);
                
                const severityIcon = {
                  critical: 'üî¥',
                  high: 'üü†',
                  medium: 'üü°',
                  low: 'üü¢'
                }[vuln.severity] || '‚ö™';
                
                const body = `### ${severityIcon} ${vuln.severity.toUpperCase()}: ${vuln.type}
            
            **Issue**: ${vuln.message}
            
            **Fix**:
            \`\`\`javascript
            ${vuln.fix}
            \`\`\`
            
            ${mlSuggestion ? `**üß† ML Insight**: ${mlSuggestion}` : ''}
            
            ${vuln.severity === 'critical' ? '‚ö†Ô∏è **This must be fixed before deployment!**' : ''}`;
                
                comments.push({
                  path: filename,
                  line: vuln.line || 1,
                  side: 'RIGHT',
                  body: body
                });
              }
            }
            
            console.log(`Posting ${comments.length} inline comments...`);
            
            if (comments.length === 0) {
              console.log('No comments to post');
              return;
            }
            
            const BATCH_SIZE = 10;
            const DELAY_MS = 2000;
            
            for (let i = 0; i < comments.length; i += BATCH_SIZE) {
              const batch = comments.slice(i, i + BATCH_SIZE);
              
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  commit_id: commitSha,
                  event: 'COMMENT',
                  comments: batch
                });
                
                console.log(`Posted ${batch.length} comments (${i + batch.length}/${comments.length})`);
                
                if (i + BATCH_SIZE < comments.length) {
                  await new Promise(resolve => setTimeout(resolve, DELAY_MS));
                }
              } catch (error) {
                console.error(`Failed to post batch starting at ${i}:`, error.message);
                
                for (const comment of batch) {
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      commit_id: commitSha,
                      path: comment.path,
                      line: comment.line,
                      side: comment.side,
                      body: comment.body
                    });
                    console.log(`Posted individual comment on ${comment.path}:${comment.line}`);
                  } catch (err) {
                    console.error(`Failed to post comment on ${comment.path}:${comment.line}:`, err.message);
                  }
                }
              }
            }
            
            console.log('Finished posting vulnerability comments');
      
      - name: Set Final Exit Code
        if: always()
        run: |
          if [[ "${FINAL_EXIT_CODE:-0}" == "1" ]]; then
            echo "‚ùå Workflow failing due to critical vulnerabilities"
            exit 1
          else
            echo "‚úÖ Workflow passing - no critical vulnerabilities"
            exit 0
          fi